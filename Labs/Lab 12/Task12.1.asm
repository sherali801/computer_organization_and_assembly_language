.MODEL SMALL
.STACK 100H
.DATA
  PROMPT1 DB 10, 13, "Enter a string: $"
  PROMPT2 DB 10, 13, "Reverse is: $"
  STR1 DB 100 DUP('$')
  STR2 DB 100 DUP('$')
.CODE
MAIN PROC
  MOV AX, @DATA
  MOV DS, AX ;DATA SEGMENT INITIALIZATION
  MOV ES, AX ;EXTRA SEGMENT INITIALIZATION SO STRING INTRUCTIONS CAN USE ES:DI

  LEA DX, PROMPT1
  MOV AH, 09H
  INT 21H ;DISPLAY PROMPT1

  CLD ;CLEAR DIRECTION FLAG SO ES:DI CAN MOVE FORWARDS
  XOR BX, BX ;INITIALIZING COUNTER TO 0
  LEA DI, STR1 ;ES:DI => DI IS POINTING TO STARTING ADDRESS OF STR1
  MOV CX, 99 ;MAX INPUT SIZE

  INPUT:
    MOV AH, 01H
    INT 21H ;SINGLE CHARACTER INPUT 
    CMP AL, 13D
    JE END_INPUT ;JUMP IF RETURN IS ENTERED
    STOSB ;MOV CONTENT OF AL TO ES:DI => WHERE DI IS POINTING AND INCREMENTING DI
    INC BX ;INCREMENTING COUNTER 
    LOOP INPUT ;CHECK WHETHER CX IS ZERO TO STOP INPUT 

  END_INPUT:
  MOV CX, BX ;BX CONTAINS TOTAL NUMBER OF CHARACTERS ENTERED (LENGTH)
  MOV SI, DI ;ES:DI POINTING TO NEXT BYTE AT WHICH LAST CHARACTER WAS MOVED 
  DEC SI ;DECREMENTING SO DS:SI CAN POINT TO LAST CHARACTER OF STR1
  LEA DI, STR2 ;STRING IN WHICH REVERSE TO BE STORED
  STD ;SETTING DIRECTION FLAG SO DS:SI CAN MOVE BACKWORDS

  REVERSE:
    MOVSB ;MOVING CONTENT OF DS:SI TO ES:DI 
    ADD DI, 2 ;MOVSB IS DECRMENTING DS:SI WHICH IS NECESSARY TO REVERSE STR1 BUT IT IS DECREMENTING ES:DI WHICH IS TO MOVE FORWARDS SO ADDING 2
    LOOP REVERSE ;ITERATE TO THE LENGTH OF STR1

  LEA DX, PROMPT2
  MOV AH, 09H
  INT 21H ;DISPLAY PROMPT2

  CLD ;CLEAR DIRECTION FLAG SO ES:DI CAN MOVE FORWARDS
  MOV CX, BX ;INITIALIZING COINTER TO THE LENGTH OF STR1/STR2
  LEA SI, STR2 ;DS:SI IS POINTING TO STARTING ADDRESS OF STR2 WHICH IS REVERSE OF STR1

  OUTPUT:
    LODSB ;MOV CONTENT OF BYTE POINTED BY DS:SI TO AL AND INCREMENTING SI
    MOV DL, AL ;DL IS USED TO OUTPUT SINGLE CHARACTER 
    MOV AH, 02H 
    INT 21H ;DISPLAY SINGLE CHARACTER
    LOOP OUTPUT ;ITERATE UNTIL CX IS ZERO TO STOP DISPLAYING CHARACTERS

  ;EXIT DOS
  MOV AH, 4CH
  INT 21H
MAIN ENDP 
END MAIN
