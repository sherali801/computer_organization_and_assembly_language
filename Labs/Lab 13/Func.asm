.CODE

;
;RETURN AX(DECIMAL INPUT)
;
DECIMAL_INPUT PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI
  PUSH BP
  DECIMAL_INPUT_OUTTER_LOOP:
    XOR BX, BX ;FIRST TIME MUL WILL RESULT IN ZERO TO ADD
    XOR CX, CX ;USE TO CHECK WETHER NUMBER IS POSITIVE OR NEGATIVE
    MOV AH, 01H 
    INT 21H ;SINGLE CHARACTER INPUT 
    CMP AL, '-' 
    JE DECIMAL_INPUT_NEGATIVE ;JUMP IF NEGATIVE
    CMP AL, '+'
    JE DECIMAL_INPUT_POSITIVE ;JUMP IF POSITIVE
    JMP DECIMAL_INPUT_INNER_LOOP ;IF NIETHER IS ENTERED THEN PROCESS IT AS POSITIVE
    DECIMAL_INPUT_NEGATIVE:
      MOV CX, 1 ;(CX = 1) IF NEGATIVE, (CX = 0) IF POSITIVE 
    DECIMAL_INPUT_POSITIVE:
      INT 21H ;SINGLE CHARACTER INPUT AFTER POSITIVE AUR NEGATIVE IS ENTERED 
    DECIMAL_INPUT_INNER_LOOP:
      CMP AL, '0' 
      JL DECIMAL_INPUT_NOT_DIGIT ;JUMP IF LESS THAN '0'
      CMP AL, '9'
      JG DECIMAL_INPUT_NOT_DIGIT ;JUMP IF GREATER THAN '9'
      AND AX, 000FH ;CONVERTING CHARACTER TO DIGIT
      PUSH AX ;SAVING ENTERED VALUE TO BE ADDED 
      MOV AX, 10  
      MUL BX ;MULTIPLY 10 WITH PREVIOUS VALUE WHICH IS IN BX AND STORE IN AX
      POP BX ;POPING ENTERED VALUE 
      ADD BX, AX ;ADDING ENTERED VALUE IN BX
      MOV AH, 01H
      INT 21H ;SINGLE CHARACTER INPUT 
      CMP AL, 13D
      JNE DECIMAL_INPUT_INNER_LOOP ;JUMP IF RETURN IN NOT ENTERED
    MOV AX, BX ;MOVING ENTERED NUMBER TO AX 
    CMP CX, 1
    JNE DECIMAL_INPUT_RETURN ;JUMP IF NUMBER ENTERED IS POSITIVE
    NEG AX ;2'S COMPLEMENT OF ENTERED NUMBER MAKING IT NEGATIVE NUMBER 
    DECIMAL_INPUT_RETURN:
      ;
      ;RESTORING CONTENT OF REGISTERS 
      ;
      POP BP
      POP DI
      POP SI
      POP DX
      POP CX
      POP BX
      RET 
    DECIMAL_INPUT_NOT_DIGIT:
      MOV AH, 09H
      LEA DX, PROMPT1
      INT 21H ;DISPLAY PROMPT1 BEACAUSE OF WRONG INPUT 
      JMP DECIMAL_INPUT_OUTTER_LOOP
DECIMAL_INPUT ENDP

;
;PARAMETER AX(NUMBER TO DISPLAY)
;
DECIMAL_OUTPUT PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI 
  PUSH BP
  CMP AX, 0
  JGE DECIMAL_OUTPUT_POSITIVE ;JUMP IF NUMBER IF GREATER THAN OR EQUAL TO ZERO
  PUSH AX ;SAVING AX WHICH IS USED TO DIPLAY NEGATIVE SIGN 
  MOV AH, 02H
  MOV DL, '-'
  INT 21H ;DISPLAY NEGATIVE SIGN
  POP AX ;RESTORING NUMBER 
  NEG AX ;2'S COMPLEMENT TO CONVERT TO EQUAVILENT POSITIVE NUMBER 
  DECIMAL_OUTPUT_POSITIVE:
  XOR CX, CX ;COUNT CHARACTERS TO DISPLAY
  MOV BX, 10D ;DIVIDE AX BY 10 TO GET REMAINDER AND RIGHT MOST DIGIT 
  DECIMAL_OUTPUT_LOOP:
    XOR DX, DX ;CLEARING DX WHICH WILL HOLD REMAINDER AFTER DIVISION
    DIV BX ;Q = AX, R = DX 
    PUSH DX ;STORING RIGHT MOST DIGIT IN STACK 
    INC CX ;INCREMENTING COUNTER 
    CMP AX, 0 
    JNE DECIMAL_OUTPUT_LOOP ;JUMP IF Q IS NOT ZERO 
  MOV AH, 02H
  DECIMAL_OUTPUT_PRINT:
    POP DX 
    ADD DL, 30H ;CONVERTING DIGIT TO CHARACTER 
    INT 21H ;DISPLAY CHARACTER 
    LOOP DECIMAL_OUTPUT_PRINT ;LOOP UNTIL CX IS ZERO
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP DI 
  POP SI 
  POP DX 
  POP CX
  POP BX 
  POP AX
  RET
DECIMAL_OUTPUT ENDP

;
;PARAMETER CX(NUMBER WHOSE FACTORIAL IS TO BE CALCULATED), RETURN AX(FACTORIL OF CX)
;
FACTORIAL PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI
  PUSH BP
  MOV AX, 1 ;MULTIPLY CX(NUMBER) WITH AX
  CMP CX, 0
  JE FACTORIAL_RETURN ;JUMP IF CX IF ZERO BEACUSE 0! IS 1
  FACTORIAL_LOOP:
    MUL CX ;N x (N - 1)!
    LOOP FACTORIAL_LOOP
  FACTORIAL_RETURN:
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP DI
  POP SI
  POP DX
  POP CX
  POP BX
  RET
FACTORIAL ENDP

;
;PARAMETERS AX(FIRST NUMBER), BX(SECOND NUMBER), RETURN DX(GCD OF AX, BX)
;
GCD PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH SI
  PUSH DI
  PUSH BP
  CMP AX, BX 
  JGE GCD_LOOP ;IF AX >= BX THEN NO NEED TO SWAP AS ALWAYS DIVIDE WITH SMALLER NUMBER 
  XCHG AX, BX ;EXCHANGE IF AX IS SMALLER THEN BX 
  GCD_LOOP: 
    XOR DX, DX 
    DIV BX ;DIVIDING AX BY BX 
    CMP DX, 0 
    JE GCD_RETURN ;IF REMAINDER IS ZERO THEN BX CONTAINS GCD 
    MOV AX, BX ;IN NEXT ITERATION AX = BX
    MOV BX, DX ;IN NEXT ITERATION BX = DX
    JMP GCD_LOOP ;JUMP UNTIL REMAINDER IS NOT ZERO
  GCD_RETURN:
  MOV DX, BX ;MOVING GCD TO DX
  ;
  ;RESTORING CONTENT OF REGISTERS 
  ;
  POP BP
  POP DI 
  POP SI 
  POP CX
  POP BX
  POP AX
  RET
GCD ENDP

;
;PARAMETERS AX(FIRST NUMBER), BX(SECOND NUMBER), RETURN DX(LCM OF AX, BX)
;
LCM PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH SI
  PUSH DI
  PUSH BP

  CALL GCD

  MOV CX, DX ;SAVING GCD BEACAUSE DX IS USED IN DIVISION 
  MUL BX ;AX = AX * BX 

  DIV CX ;AX = ((AX * BX) / GCD)

  MOV DX, AX ;LCM OF AX AND BX
  ;
  ;RESTORING CONTENT OF REGISTERS 
  ;
  POP BP
  POP DI
  POP SI
  POP CX
  POP BX
  POP AX
  RET
LCM ENDP
