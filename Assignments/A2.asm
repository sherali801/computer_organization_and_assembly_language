.MODEL SMALL
.STACK 100H
.DATA
  PROMPT1 DB 10, 13, "Segment address: $"
  PROMPT2 DB 10, 13, "Starting offset address: $"
  PROMPT3 DB 10, 13, "Ending offset address: $"
.CODE
MAIN PROC
  MOV AX, @DATA
  MOV DS, AX ;INTIALIZATION OF DATA SEGMENT 
  LEA DX, PROMPT1 ;PARAMETER FOR HEX_INPUT (PROMPT TO DISPLAY)
  MOV CH, 4 ;PARAMETER FOR HEX_INPUT (HOW MANY CHARACTERS TO INPUT)
  CALL HEX_INPUT
  PUSH BX ;STORING SEGMENT ADDRESS
  LEA DX, PROMPT2 ;PARAMETER FOR HEX_INPUT (PROMPT TO DISPLAY)
  MOV CH, 4 ;PARAMETER FOR HEX_INPUT (HOW MANY CHARACTERS TO INPUT)
  CALL HEX_INPUT
  PUSH BX ;STORING STARTING OFFSET ADDRESS 
  LEA DX, PROMPT3 ;PARAMETER FOR HEX_INPUT (PROMPT TO DISPLAY)
  MOV CH, 4 ;PARAMETER FOR HEX_INPUT (HOW MANY CHARACTERS TO INPUT)
  CALL HEX_INPUT
  PUSH BX ;STORING ENDING OFFSET ADDRESS 
  MOV AH, 02H
  MOV DL, 10
  INT 21H ;DISPLAY CARRIGE RETURN
  MOV DL, 13
  INT 21H ;DISPLAY NEW LINE
  MOV BP, SP ;BP CAN MOVE IN STACK SEGMENT 
  MOV DS, [BP + 4];SEGMENT ADDRESS 
  MOV AX, [BP + 2];STARTING OFFSET ADDRESS, PARAMETER FOR BOUNDARY_ADDRESS
  CALL BOUNDARY_ADDRESS
  SUB AX, DX ;FROM WHERE TO START PRINTING (BOUNDARY ADDRESS) 
  MOV SI, AX 
  OUTTER_LOOP:
    MOV BX, [BP + 4];SEGMENT ADDRESS, PARAMETER FOR PRINT_HEX BX(WHAT TO PRINT)
    MOV CH, 4 ;PARAMETER FOR PRINT_HEX CH(HOW MANY CHARACTERS TO PRINT)
    CALL PRINT_HEX
    MOV AH, 02H
    MOV DL, ':'
    INT 21H ;DISPLAY COLON BETWEEN SEGMENT AND OFFSET 
    MOV BX, SI ;OFFSET ADDRESS, PARAMETER FOR PRINT_HEX BX(WHAT TO PRINT)
    MOV CH, 4 ;PARAMETER FOR PRINT_HEX CH(HOW MANY CHARACTERS TO PRINT)
    CALL PRINT_HEX
    MOV AH, 02H
    MOV DL, ' '
    INT 21H ;DISPLAY SPACE 
    INT 21H ;DISPLAY SPACE 
    MOV DI, SI ;PARAMETER FOR PRINT_HEX_SIXTEEN_BYTES DI(STARTING ADDRESS FROM WHERE TO START PRINTING)
    CALL PRINT_HEX_SIXTEEN_BYTES
    MOV AH, 02H
    MOV DL, ' '
    INT 21H ;DISPLAY SPACE
    INT 21H ;DISPLAY SPACE
    MOV DI, SI ;PARAMETER FOR PRINT_ASCII DI(STARTING ADDRESS FROM WHERE TO START PRINTING)
    CALL PRINT_ASCII
    MOV AH, 02H
    MOV DL, 10
    INT 21H ;DISPLAY CARRIGE RETURN
    MOV DL, 13
    INT 21H ;DISPLAY NEW LINE
    MOV SI, DI ;DI IS ALREADY POINTING TO STARTING ADDRESS OF NEXT 16 BYTES
    CMP SI, [BP] ;ENDING OFFSET ADDRESS 
    JLE OUTTER_LOOP ;ITERATE UNTIL STARTING OFFSET ADDRESS IS LESS THAN OR EQUAL TO ENDING OFFSET ADDRESS 
  MOV AH, 4CH
  INT 21H ;EXIT DOS
MAIN ENDP

;
;PARAMETERS ARE DX(PROMPT), CH(NUMBER OF CHARACTERS TO INPUT), RETURN BX(4-HEX DIGITS)
;
HEX_INPUT PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI
  PUSH BP
  MOV AH, 09H
  INT 21H ;DISPLAY PROMPT IN DX
  XOR BX, BX ;HOLD INPUT FROM USER
  MOV CL, 4 ;USE IN SHIFTING (NUMBER OF BITS TO SHIFT)
  HEX_INPUT_LOOP:
    MOV AH, 01H 
    INT 21H ;SINGLE CHARACTER INPUT 
    CMP AL, '0'
    JL HEX_INPUT_WRONG ;JUMP IF LESS THAN '0'
    CMP AL, '9'
    JLE HEX_INPUT_DIGIT ;JUMP IF LESS THAN '9'
    CMP AL, 'A'
    JL HEX_INPUT_WRONG ; JUMP IF LESS THAN 'A'
    CMP AL, 'Z'
    JLE HEX_INPUT_CHARACTER ;JUMP IF LESS THAN 'Z'
    HEX_INPUT_WRONG:
      XOR BX, BX ;WIPING PREVIOUS CONTENT 
      MOV CH, 4 ;STARTING COUNTER AGAIN
      MOV AH, 09H 
      INT 21H ;DISPLAY PROMPT IN DX
      JMP HEX_INPUT_LOOP ;STARTING TAKING INPUT AGAIN
    HEX_INPUT_DIGIT:
      SUB AL, 30H ;CONVERTING TO DIGIT 
      JMP HEX_INPUT_STORE
    HEX_INPUT_CHARACTER:
      SUB AL, 37H ;CONVERTING TO CHARACTER
    HEX_INPUT_STORE:
      SHL BX, CL ;SHIFTING LOWER NIBBLE TO UPPER NIBBLE 
      OR BL, AL ;MAKING USER INPUT AS RIGHT MOST DIGIT IN BX 
    DEC CH ;DECEMENTING COUNTER
    JNZ HEX_INPUT_LOOP
    ;
    ;RESTORING CONTENT OF REGISTERS
    ;
    POP BP
    POP DI
    POP SI
    POP DX
    POP CX
    POP AX
    RET 
HEX_INPUT ENDP

;
;PARAMETERS ARE BX(HOLD WHICH IS TO BE PRINTED), CH(HOW MANY TO PRINT)
;
PRINT_HEX PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH DI
  PUSH BP
  MOV CL, 4 ;USE IN SHIFTING (NUMBER OF BITS TO SHIFT)
  PRINT_HEX_OUTPUT:
    MOV DL, BH ;ALWAYS DISPLAY UPPER BYTE
    SHR DL, CL ;ALWAYS DISPLAY LOWER NIBBLE OF UPPER BYTER
    CMP DL, 9 
    JLE PRINT_HEX_DIGIT ;JUMP IF IT'S A DIGIT 
    ADD DL, 37H ;CONVERTING TO CHARCATER 
    JMP PRINT_HEX_DISPLAY
    PRINT_HEX_DIGIT:
      ADD DL, 30H ;CONVERTING TO DIGIT 
    PRINT_HEX_DISPLAY:
      MOV AH, 02H ;DISPLAY CHARACTER 
      INT 21H
    ROL BX, CL ;MOVING LOWER NIBBLE TO UPPER NIBBLE
    DEC CH ;DECREMENTING COUNTER
    JNZ PRINT_HEX_OUTPUT ;JUMP IF COUNTER IT NOT ZERO
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP DI
  POP SI
  POP DX
  POP CX
  POP BX
  POP AX
  RET
PRINT_HEX ENDP

;
;PARAMETERS ARE DI(HOLD STARTING OFFSET ADDRESS OF 8 BYTES TO BE PRINTED)
;
PRINT_HEX_SIXTEEN_BYTES PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH BP
  MOV BP, SP 
  MOV CX, 16 ;NUMBER OF BYTES IN EACH LINE 
  PRINT_HEX_SIXTEEN_BYTES_OUTPUT:
    PUSH CX ;STORING COUNTER AS CH IS USED FOR PRINT_HEX FUNCTION
    CMP DI, [BP + 14 + 2] ;STARTING OFFSET ADDRESS
    JL PRINT_HEX_SIXTEEN_BYTES_SPACES ;JUMP IF CURRENT ADDRESS IS LESS THAN STARTING OFFSET ADDRESS
    CMP DI, [BP + 14 + 0] ;ENDING OFFSET ADDRESS
    JG PRINT_HEX_SIXTEEN_BYTES_SPACES ;JUMP IF CURRENT ADDRESS IS GREATER THAN ENDING OFFSET ADDRESS
    MOV BH, [DI] ;PARAMETER FOR PRINT_HEX FUNCTION (STARTING ADDRESS OF WHAT TO PRINT)
    MOV CH, 2 ;PARAMETER FOR PRINT_HEX FUNCTION (HOW MANY CHARACTERS TO PRINT)
    CALL PRINT_HEX
    POP CX ;RESTORING COUNTER
    CMP CX, 9 ;PRINT HYPEN AFTER PRINTING 7H BYTE 
    JE PRINT_HEX_SIXTEEN_BYTES_HYPEN ;JUMP IF COUNTER IS 9
    MOV DL, ' ' 
    MOV AH, 02H 
    INT 21H ;DISPLAY SPACE
    JMP PRINT_HEX_SIXTEEN_BYTES_NEXT
    PRINT_HEX_SIXTEEN_BYTES_HYPEN:
    MOV AH, 02H
    MOV DL, '-'
    INT 21H ;DISPLAY HYPEN 
    JMP PRINT_HEX_SIXTEEN_BYTES_NEXT
    PRINT_HEX_SIXTEEN_BYTES_SPACES:
      POP CX ; RESTORING COUNTER
      MOV AH, 02H
      MOV DL, ' '
      INT 21H ;DISPLAY SPACE 
      INT 21H ;DISPLAY SPACE 
      INT 21H ;DISPLAY SPACE 
    PRINT_HEX_SIXTEEN_BYTES_NEXT:
    INC DI ;INCREMENTING TO PRINT NEXT BYTE 
    LOOP PRINT_HEX_SIXTEEN_BYTES_OUTPUT
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP SI
  POP DX
  POP CX
  POP BX
  POP AX
  RET
PRINT_HEX_SIXTEEN_BYTES ENDP

;
;PARAMETERS ARE DI(HOLD STARTING OFFSET ADDRESS OF 16 BYTES TO BE PRINTED)
;
PRINT_ASCII PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  PUSH SI
  PUSH BP
  MOV BP, SP 
  MOV CX, 16 ;NUMBER OF BYTES IN EACH LINE
  PRINT_ASCII_OUTPUT:
    CMP DI, [BP + 12 + 4] ;STARTING OFFSET ADDRESS
    JL PRINT_ASCII_SPACES ;JUMP IF CURRENT ADDRESS IS LESS THAN STARTING OFFSET ADDRESS
    CMP DI, [BP + 12 + 2] ;ENDING OFFSET ADDRESS
    JG PRINT_ASCII_SPACES ;JUMP IF CURRENT ADDRESS IS GREATER THAN ENDING OFFSET ADDRESS
    MOV DL, [DI] ;MOVING CONTENT OF DI TO PRINT 
    CMP DL, 20H
    JL PRINT_ASCII_DOT ;JUMP IF LESS THEN 20H
    CMP DL, 7EH
    JG PRINT_ASCII_DOT ;JUMP IF GREATER THEN 73H 
    JMP PRINT_ASCII_DISPLAY
    PRINT_ASCII_DOT:
      MOV DL, '.' ;DISPLAY (.)
      PRINT_ASCII_DISPLAY:
        MOV AH, 02H
        INT 21H ;DISPLAY CHARCATER
      JMP PRINT_ASCII_REMAIN
    PRINT_ASCII_SPACES:
      MOV AH, 02H
      MOV DL, ' '
      INT 21H ;DISPLAY SPACES 
    PRINT_ASCII_REMAIN:
    INC DI ;INCREMENTINFG DI SO IT CAN POINT TO NEXT BYTE TO PRINT 
    LOOP PRINT_ASCII_OUTPUT
  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP SI
  POP DX
  POP CX
  POP BX
  POP AX
  RET
PRINT_ASCII ENDP

;
;PARAMETER AX(ADDRESS), RETURN DX(DIFFERENCE FROM BOUNDARY ADDRESS)
;
BOUNDARY_ADDRESS PROC
  ;
  ;SAVING CONTENT OF REGISTERS
  ;
  PUSH AX
  PUSH BX
  PUSH CX
  PUSH SI
  PUSH DI
  PUSH BP

  MOV BX, 16 ;DIVIDING BY 16 WILL GIVE RIGHT MOST DIGIT 
  XOR DX, DX ;STORE REMAINDER OR RIGHT MOST DIGIT 
  DIV BX ;Q = AX, R = DX

  ;
  ;RESTORING CONTENT OF REGISTERS
  ;
  POP BP
  POP DI
  POP SI
  POP CX
  POP BX
  POP AX
  RET
BOUNDARY_ADDRESS ENDP

END MAIN